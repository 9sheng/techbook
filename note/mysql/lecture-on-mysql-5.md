# 38 | 都说InnoDB好，那还要不要使用Memory引擎?
- InnoDB和Memory引擎的数据组织方式的不同
  - InnoDB引擎把数据放在主键索引上，其他索引上保存的是主键id，称之为索引组织表(Index Organizied Table)。 
  - Memory引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，称之为堆组织表(Heap Organizied Table)。
- 为什么不建议你在生产环境上使用内存表
  - 锁粒度问题； 内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。
  - 数据持久化问题。
  - 由于重启会丢数据，如果一个备库重启，临时表会导致主备同步线程停止；如果主库跟这个备库是双M架构，还可能导致主库的内存表数据被删掉。

# 39 | 自增主键为什么不是连续的?
- 不同的引擎对于自增值的保存策略不同。
  - MyISAM引擎的自增值保存在数据文件中。 
  - InnoDB引擎的自增值，其实是保存在了内存里，并且到了MySQL 8.0版本后，才有了“自增值 持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”。
  - 在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一 次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。
- 唯一键冲突是导致自增主键id不连续。
- 事务回滚也会产生主键id不连续。如果硬要连续，会导致冲突、性能问题。
- 主键分配策略导致。insert...select，实际上往表t2中插入了4行数据。但是，这四行数据是分三次申请的自增id，第一 次申请到了id=1，第二次被分配了id=2和id=3， 第三次被分配到id=4到id=7。
- MySQL 5.1.22版本开始引入的参数`innodb_autoinc_lock_mode`，控制了自增值申请时的锁范围。从并发性能的角度考虑，建议将其设置为2，同时将`binlog_format`设置为row。

# 40 | insert语句的锁为什么这么多?
- insert ...select 是很常见的在两个表之间拷贝数据的方法。在可重复读隔离级别下，这个语句会给select的表里扫描到的记录和间隙加读锁。 而如果insert和select的对象是同一个表，则有可能会造成循环写入。这种情况下，需要引入用户临时表来做优化。
- insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的next-key lock(S锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。

# 41 | 怎么最快地复制一张表?
- mysqldump `–single-transaction`的作用是，在导出数据的时候不需要对表加表锁，而是使用START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；
- 物理拷贝表的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况， 用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：必须是全表拷贝，不能只拷贝部分数据； 需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用； 由于是通过拷贝物理文件实现的，源表和目标表都是使用InnoDB引擎时才能使用。
- 用mysqldump生成包含INSERT语句文件的方法，可以在where参数增加过滤条件，来实现只导出部分数据。这个方式的不足之一是，不能使用join这种比较复杂的where条件写法。
- 用select...intooutfile的方法是最灵活的，支持所有的SQL写法。但这个方法的缺点之一是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。

> 后两种方式都是逻辑备份方式，是可以跨引擎使用的。

# 42 | grant之后要跟着flush privileges吗?
```sh
create user 'ua'@'%' identified by 'pa'；
grant all privileges on *.* to 'ua'@'%' with grant option；
revoke all privileges on *.* from 'ua'@'%'；
```
- grant语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用 grant和revoke语句，是不需要随后加上flush privileges语句的。
- flush privileges语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不 一致的情况下再使用。而这种不一致往往是由于直接用DML语句操作系统权限表导致的，所以尽量不要使用这类语句。

# 43 | 要不要使用分区表?

# 44 | 答疑文章(三):说一说这些好问题
- 在MySQL里，NULL跟任何值执行等值 判断和不等值判断的结果，都是NULL。这里包括， select NULL = NULL 的结果，也是返回 NULL。
- 不需要执行聚合函数时，distinct 和group by这两条语句的语义和执行流程是相同的，因此执行性能也相同。

# 45 | 自增id用完怎么办?
- Xid和InnoDB的trx_id是两个容易混淆的概念。 Xid是由server层维护的。InnoDB内部使用Xid，就是为了能够在InnoDB事务和server之间做关联。但InnoDB自己的trx_id是另外维护的。
- 只读事务不分配trx_id，有什么好处呢?
  - 可以减小事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB就只需要 拷贝读写事务的trx_id。
  - 可以减少trx_id的申请次数。在InnoDB里，即使你只是执行一个普通的select 语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请trx_id，就大大减少了并发事务申请trx_id的锁冲突。
- 每种自增id有各自的应用场景，在达到上限后的表现也不同:
  - 表的自增id达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。
  - row_id达到上限后，则会归0再重新递增，如果出现相同的row_id，后写的数据会覆盖之前 的数据。
  - Xid只需要不在同一个binlog文件中出现重复值即可。虽然理论上会出现重复值，但是概率极 小，可以忽略不计。
  - InnoDB的max_trx_id递增值每次MySQL重启都会被保存起来，所以我们文章中提到的脏读 的例子就是一个必现的bug，好在留给我们的时间还很充裕。
  - thread_id是我们使用中最常见的，而且也是处理得最好的一个自增id逻辑了。
