作者：李运华

------
## 01 架构是什么
- 作者的定义：软件架构指软件系统的顶层结构。
- 架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。

## 02 架构设计的历史背景
- 第一次软件危机与结构化程序设计(20世纪60年代~20世纪70年代)：结构化程序设计的主要特点是抛弃 goto 语句，采取“自顶向下、逐步细化、模块化”的指导思想。
- 第二次软件危机与面向对象(20世纪80年代)：主要体现在软件的“扩展”变得非常复杂。
- 布鲁克斯发表《人月神话》三十年后，又写了《设计原本》。他认为一个成功的软件项目的最重要因素就是设计，架构师、设计师需要在业务需求和IT技术中寻找到一个平衡点。 
- 软件设计过程中，模块、对象、组件本质上是对一定规模软件在不同粒度和层次上的“拆分”方法论，软件架构是一种对软件的“组织”方法论。

## 03 架构设计的目的
- 架构设计的主要目的是为了解决软件系统复杂度带来的问题。
- 架构抉择的主要因素：性能、可扩展性、高可用、安全性、成本（时间、人力）等方面的量化需求（要求）。

## 04 高性能
- 多核计算机架构：SMP(Symmetric Multi-Processor，对称多处理器结构)、NUMA(Non-Uniform Memory Access，非一致存储访问结构)、MPP(Massive Parallel Processing，海量并行处理结构)。其中SMP是我们最常见的，目前流行的多核处理器就是SMP方案。
- 任务分配器：常见的方法包括DNS轮询、智能DNS、CDN(Content Delivery Network，内容分发网络)、GSLB设备(Global Server Load Balance，全局负载均衡)等。
- 假设这些系统采用IP网络连接，理想情况下一次请求和响应在网络上耗费为1ms，业务处理本身耗时为50ms。
- 为什么要拆分为子系统
  - 简单的系统更加容易做到高性能
  - 可以针对单个任务进行扩展

## 05 高可用
- 系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。
- 从广州机房到北京机房，稳定情况下ping延时大约是50ms，不稳定情况下可能达到1s甚至更多。

## 06 可扩展性
- 正确预测变化、完美封装变化。

## 07 低成本、安全、规模
- 常见的 XSS 攻击、CSRF 攻击、SQL 注入、Windows 漏洞、密码破解。
- 传统企业主要通过防火墙实现不同区域的访问控制，功能强大、性能一般，但是成本更高。互联网企业更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现。
- 目前的大数据理论基础是 Google 发表的三篇大数据相关论文，其中 Google File System 是大数据文件存储的技术理论，Google Bigtable 是列式数据存储的技术理论，Google MapReduce 是大数据运算的技术理论。

## 08 架构设计三原则
- 合适原则：合适优于业界领先
- 简单原则：简单优于复杂
  - 结构复杂性：模块太多，模块关联太复杂
  - 逻辑复杂性：模块少，单个模块的复杂性太高，带来问题
- 演化原则：演化优于一步到位
  - 首先，设计出来的架构要满足当时的业务需要
  - 其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善
  - 第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等(类似生物体内的基因)却可以在新架构中延续

## 09 架构设计原则案例
淘宝 和 QQ 的架构演进

## 10 架构设计流程：识别复杂度
- 正确的做法是将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题
- 对于架构师来说，常见系统的性能量级需要烂熟于心，例如，nginx负载均衡性能是3万左右， memcache的读取性能5万左右，kafka号称百万级，zookeeper写入读取2万以上，http请求访问大概在2万左右。
- 架构师推动是主要的，架构师需要五项全能：技术，沟通，推动，管理，撕逼

## 11 架构设计流程：设计备选方案
- 第一种常见的错误：设计最优秀的方案
- 第二种常见的错误：只做一个方案
  - 备选方案的数量以 3~5 个为最佳。少于 3 个方案可能是因为思维狭隘，考虑不周全；多于 5 个则需要耗费大量的精力和时间，并且方案之间的差别可能不明显。
  - 备选方案的差异要比较明显。例如，主备方案和集群方案差异就很明显，或者同样是主备方案，用 ZooKeeper 做主备决策和用 Keepalived 做主备决策的差异也很明显。
  - 备选方案的技术不要只局限于已经熟悉的技术。设计架构时，架构师需要将视野放宽，考虑更多可能性。架构师对 MySQL 很熟悉，因此不管什么存储都基于 MySQL 去设计方案，系统性能不够了，首先考虑的就是 MySQL 分库分表，而事实上也许引入一个 Memcache 缓存就能够解决问题
- 第三种常见的错误：备选方案过于详细
- 架构师的技术储备越丰富、经验越多，备选方案也会更多，从而才能更好地设计备选方案。例如，开源方案选择可能就包括 Kafka、ActiveMQ、RabbitMQ;集群方案的存储既可以考虑用MySQL， 也可以考虑用HBase，还可以考虑用 Redis 与 MySQL 结合等；自研文件系统也可以有多个， 可以参考 Kafka，也可以参考 LevelDB，还可以参考 HBase 等

## 12 架构设计流程：评估和选择备选方案
- 列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案
- 常见的方案质量属性点有:性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等。在评估这些质量属性时，需要遵循架构设计原则 1“合适原则”和原则 2“简单原则”，避免贪大求全，基本上某个质量属性能够满足一定时期内业务发展就可以了
- 引入开源方案工作量小，但是可运维性和可扩展性差；自研工作量大，但是可运维和可维护性好

**RocketMQ 和 Kafka 有什么区别**
- Kafka适合日志处理；RocketMQ适合业务处理
- Kafka单机写入TPS号称在百万条/秒；RocketMQ大约在10万条/秒。Kafka单机性能更高。
- 均支持pull长轮询，RocketMQ消息实时性更好
- Kafka单机超过64个队列/分区，消息发送性能降低严重；RocketMQ单机支持最高5万个队列，性能稳定(这也是适合业务处理的原因之一)
- 数据可靠性：kafka使用异步刷盘方式，异步Replication；RocketMQ支持异步刷盘，同步刷盘，同步Replication，异步Replication
- 严格的消息顺序：Kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序；RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机后，发送消息会失败，但是不会乱序
- Kafka消费失败不支持重试，RocketMQ消费失败支持定时重试，每次重试间隔时间顺延
- 消费失败重试机制：定时消息：Kafka不支持定时消息，RocketMQ支持定时消息
- Kafka不支持分布式事务消息，阿里云ONS支持分布式定时消息，未来开源版本的RocketMQ也有计划支持分布式事务消息
- 消息查询机制：Kafka不支持消息查询，RocketMQ支持根据Message Id查询消息，也支持根据消息内容查询消息(发送消息时指定一个Message Key，任意字符串，例如指定为订单Id)
- 消息回溯：Kafka理论上可以按照Offset来回溯消息；RocketMQ支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息

## 13 架构设计流程：详细方案设计
- Nginx 的负载均衡策略，备选有轮询、权重分配、ip_hash、fair、url_hash 五个，具体选哪个呢？
- 详细设计方案阶段可能遇到的一种极端情况就是在详细设计阶段发现备选方案不可行，一般情况下主要的原因是备选方案设计时遗漏了某个关键技术点或者关键的质量属性
- 架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解，如es的索性设计就是关键设计点
- 就一些新的技术引入，架构师需要做哪些技术验证，或者研究到什么深度以后，才认为该技术适合呢?作者回复：基本原理，优点缺点，关键设计点，架构师至少要安装过，编写demo体验过，确定选型后，要进行性能和可用性测试例
